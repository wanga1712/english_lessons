<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ö–∞—Ä—Ç–∞ –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–π</title>
  {% load static %}
  
  <!-- Phaser 3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      min-height: 100vh;
      padding: 20px;
      overflow-x: hidden;
      overflow-y: auto;
    }
    
    .teacher-button {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 30px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 15px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
      text-decoration: none;
      z-index: 1000;
      transition: transform 0.2s;
    }
    
    .teacher-button:hover {
      transform: translateY(-2px);
    }
    
    .game-container {
      max-width: 1600px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      min-height: 700px;
      overflow: visible;
    }
    
    .stats-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
    }
    
    .game-map-wrapper {
      position: relative;
      width: 100%;
      height: 600px;
      background: linear-gradient(135deg, #87CEEB 0%, #98D8C8 50%, #F7DC6F 100%);
      border-radius: 15px;
      border: 5px solid #8b4513;
      overflow: hidden;
      cursor: grab;
    }
    
    .game-map-wrapper:active {
      cursor: grabbing;
    }
    
    #phaser-game {
      width: 100%;
      height: 100%;
    }
    
    .zoom-controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .zoom-btn {
      width: 40px;
      height: 40px;
      background: white;
      border: 2px solid #667eea;
      border-radius: 8px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: all 0.2s;
    }
    
    .zoom-btn:hover {
      background: #667eea;
      color: white;
    }
    
    .stars {
      color: #FFD700;
      font-size: 1.2rem;
    }
    
    .map-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 0.9rem;
      color: #666;
      z-index: 100;
    }
  </style>
</head>
<body>
  <a href="/teacher/" class="teacher-button">üë®‚Äçüè´ –ü–∞–Ω–µ–ª—å —É—á–∏—Ç–µ–ª—è</a>
  
  <div class="game-container">
    <h1 style="text-align: center; color: #667eea; margin-bottom: 20px;">üó∫Ô∏è –ö–∞—Ä—Ç–∞ –ü—Ä–∏–∫–ª—é—á–µ–Ω–∏–π</h1>
    
    <div class="stats-panel">
      <div class="stat-card">
        <h3 id="completedLessons">0</h3>
        <p>–ü—Ä–æ–π–¥–µ–Ω–æ —É—Ä–æ–∫–æ–≤</p>
      </div>
      <div class="stat-card">
        <h3 id="totalStars">0</h3>
        <p>‚≠ê –ó–≤—ë–∑–¥ —Å–æ–±—Ä–∞–Ω–æ</p>
      </div>
      <div class="stat-card">
        <h3 id="userScore">0</h3>
        <p>–ë–∞–ª–ª–æ–≤</p>
      </div>
    </div>
    
    <div class="game-map-wrapper" id="mapWrapper">
      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomIn">+</button>
        <button class="zoom-btn" id="zoomOut">‚àí</button>
        <button class="zoom-btn" id="resetView">‚åÇ</button>
      </div>
      <div id="phaser-game"></div>
      <div class="map-hint">üñ±Ô∏è –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç—É –º—ã—à—å—é | üîç –ö–æ–ª–µ—Å–∏–∫–æ –º—ã—à–∏ –¥–ª—è –∑—É–º–∞</div>
    </div>
    
    <div style="margin-top: 20px; text-align: center; color: #666;">
      <p><strong>–°–∏—Å—Ç–µ–º–∞ –∑–≤—ë–∑–¥:</strong></p>
      <p>1‚≠ê = 50-69% | 2‚≠ê = 70-99% | 3‚≠ê = 100% –±–µ–∑ –æ—à–∏–±–æ–∫</p>
      <p><em>–î–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–∫–∞ –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –º–∏–Ω–∏–º—É–º 2‚≠ê</em></p>
    </div>
  </div>
  
  <script>
    // #region agent log
    const DEBUG_LOG_ENDPOINT = 'http://127.0.0.1:7244/ingest/47fa6f77-db98-4c70-bd7a-f564ec61d812';
    function logDebug(location, message, data, hypothesisId) {
      const logData = {
        location: location,
        message: message,
        data: data || {},
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'run1',
        hypothesisId: hypothesisId || 'A'
      };
      fetch(DEBUG_LOG_ENDPOINT, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(logData)
      }).catch(() => {});
      console.log(`[${location}] ${message}`, data || '');
    }
    // #endregion
    
    // Game data
    let gameInstance = null;
    let lessons = [];
    let completedLessons = new Set();
    let lessonStars = {};
    let avatarData = {name: '–£—á–µ–Ω–∏–∫', emoji: 'üéì', score: 0.0};
    
    {% if avatar_data_json %}
    try {
      avatarData = JSON.parse('{{ avatar_data_json|escapejs }}');
    } catch(e) {
      console.warn('Could not parse avatar data:', e);
    }
    {% endif %}
    
    // Lesson positions on map - –æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–Ω–æ–≥–æ –º–∏—Ä–∞ (3000x3000)
    const lessonPositions = [
      {x: 300, y: 300}, {x: 600, y: 250}, {x: 900, y: 300}, {x: 1200, y: 250},
      {x: 1500, y: 300}, {x: 1800, y: 250}, {x: 2400, y: 450}, {x: 2100, y: 500},
      {x: 1800, y: 480}, {x: 1350, y: 570}, {x: 900, y: 600}, {x: 450, y: 675},
      {x: 600, y: 825}, {x: 1050, y: 750}, {x: 1500, y: 825}, {x: 1950, y: 780},
      {x: 2400, y: 870}, {x: 2550, y: 1050}, {x: 2100, y: 1125}, {x: 1650, y: 1080},
      {x: 1200, y: 1170}, {x: 750, y: 1125}, {x: 450, y: 1200}, {x: 900, y: 1275},
      {x: 1500, y: 1320}
    ];
    
    // Phaser Game Configuration
    const config = {
      type: Phaser.AUTO,
      parent: 'phaser-game',
      width: 800,
      height: 600,
      backgroundColor: '#87CEEB',
      physics: {
        default: 'arcade',
        arcade: {
          debug: false
        }
      },
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };
    
    // Phaser Scene Functions
    function preload() {
      const scene = this;
      
      // Load new hero sprite - 5 rows √ó 10 cols = 50 frames, 73√ó98px each
      const heroPath = '{% static "lessons/img/characters/hero-new.jpg" %}';
      console.log('üñºÔ∏è Loading new hero image from:', heroPath);
      
      // #region agent log
      logDebug('home_uchi_hero.html:preload', 'Loading new hero as single image for grid extraction', {
        heroPath,
        imageSize: '735x490',
        gridStructure: '5 rows √ó 10 cols = 50 frames',
        frameSize: '73√ó98px',
        approach: 'canvas_texture_extraction'
      }, 'A');
      // #endregion
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞–∫ –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–Ω–µ —Å–ø—Ä–∞–π—Ç-–ª–∏—Å—Ç)
      scene.load.image('hero-full', heroPath);
      
      // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Å–µ—Ç–∫–∏ —Å–ø—Ä–∞–π—Ç–æ–≤ –Ω–æ–≤–æ–≥–æ –≥–µ—Ä–æ—è
      // –°–ø—Ä–∞–π—Ç-–ª–∏—Å—Ç –∏–º–µ–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É: 5 —Ä—è–¥–æ–≤ √ó 10 –∫–æ–ª–æ–Ω–æ–∫ = 50 –∫–∞–¥—Ä–æ–≤
      scene.heroImageKey = 'hero-full';
      scene.heroImageWidth = 735;
      scene.heroImageHeight = 490;
      
      // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–µ—Ç–∫–∏: 5 —Ä—è–¥–æ–≤ √ó 10 –∫–æ–ª–æ–Ω–æ–∫ = 50 –∫–∞–¥—Ä–æ–≤
      scene.heroGridRows = 5;
      scene.heroGridCols = 10;
      scene.heroFrameWidth = 73;  // 735 / 10 = 73.5, –æ–∫—Ä—É–≥–ª—è–µ–º –¥–æ 73
      scene.heroFrameHeight = 98; // 490 / 5 = 98
      scene.heroTotalFrames = 50; // 5 √ó 10
      
      // #region agent log
      logDebug('home_uchi_hero.html:preload', 'Grid spritesheet config set', {
        gridRows: scene.heroGridRows,
        gridCols: scene.heroGridCols,
        frameWidth: scene.heroFrameWidth,
        frameHeight: scene.heroFrameHeight,
        totalFrames: scene.heroTotalFrames
      }, 'A');
      // #endregion
      
      // –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–≥—Ä—É–∑–∫—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      scene.load.on('filecomplete-image-hero-full', () => {
        console.log('‚úÖ hero-full image loaded (735x490, will create frame textures from grid)');
        
        // –°–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–¥—Ä–∞ –∏–∑ —Å–µ—Ç–∫–∏
        const gridRows = scene.heroGridRows || 5;
        const gridCols = scene.heroGridCols || 10;
        const frameWidth = scene.heroFrameWidth || 73;
        const frameHeight = scene.heroFrameHeight || 98;
        const totalFrames = scene.heroTotalFrames || 50;
        
        const sourceTexture = scene.textures.get('hero-full');
        
        if (sourceTexture && sourceTexture.source[0]) {
          const sourceImage = sourceTexture.source[0].image;
          
          console.log(`üìê Creating textures from grid: ${gridRows} rows √ó ${gridCols} cols = ${totalFrames} frames`);
          console.log(`   Frame size: ${frameWidth}x${frameHeight}`);
          
          // –°–æ–∑–¥–∞–µ–º canvas –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–¥—Ä–∞
          let frameIndex = 0;
          for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
              const canvas = document.createElement('canvas');
              canvas.width = frameWidth;
              canvas.height = frameHeight;
              const ctx = canvas.getContext('2d');
              
              // –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
              const sourceX = col * frameWidth;
              const sourceY = row * frameHeight;
              
              // –†–∏—Å—É–µ–º –Ω—É–∂–Ω—É—é —á–∞—Å—Ç—å –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
              ctx.drawImage(
                sourceImage,
                sourceX, sourceY, frameWidth, frameHeight,  // source (–∏–∑ —Å–µ—Ç–∫–∏)
                0, 0, frameWidth, frameHeight  // destination
              );
              
              // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–∫ —Ç–µ–∫—Å—Ç—É—Ä—É –≤ Phaser
              scene.textures.addCanvas(`hero-frame-${frameIndex}`, canvas);
              
              if (frameIndex < 5 || frameIndex >= totalFrames - 5) {
                console.log(`   Created texture: hero-frame-${frameIndex} (row ${row}, col ${col}, pos ${sourceX},${sourceY})`);
              }
              
              frameIndex++;
            }
          }
          
          console.log(`‚úÖ Created ${totalFrames} frame textures from grid`);
          
          // #region agent log
          logDebug('home_uchi_hero.html:preload', 'Frame textures created from grid', {
            imageWidth: 735,
            imageHeight: 490,
            gridRows,
            gridCols,
            frameWidth,
            frameHeight,
            totalFrames,
            texturesCreated: totalFrames
          }, 'A');
          // #endregion
        } else {
          console.error('‚ùå Cannot create frame textures: source texture not found');
        }
      });
      
      // Load tileset for map background
      scene.load.image('tileset', '{% static "lessons/img/tileset/all.png" %}');
      
      // Add load error listener
      scene.load.on('loaderror', (file) => {
        console.error('‚ùå Error loading file:', file.key, file.src);
      });
      
      console.log('‚úÖ Phaser preload started');
    }
    
    function create() {
      const scene = this;
      
      // Get canvas dimensions
      const mapWrapper = document.getElementById('mapWrapper');
      const width = mapWrapper.clientWidth;
      const height = mapWrapper.clientHeight;
      
      // Resize game
      scene.scale.resize(width, height);
      
      // Create camera with bounds - —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä –º–∏—Ä–∞ –¥–ª—è –ª—É—á—à–µ–≥–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è
      const worldWidth = 3000;
      const worldHeight = 3000;
      scene.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
      scene.cameras.main.setZoom(1);
      
      // Create map background - Heroes 3 style with grass/earth tiles
      createMapBackground(scene);
      
      // Store scene reference for later use
      scene.lessonSprites = [];
      scene.heroSprite = null;
      scene.paths = [];
      
      // Create hero animations from spritesheet
      createHeroAnimations(scene);
      
      // Load lessons from API
      loadLessons(scene);
      
      // Setup camera controls
      setupCameraControls(scene);
      
      console.log('‚úÖ Phaser scene created');
    }
    
    // Create hero animations - –Ω–µ –Ω—É–∂–Ω—ã, —Ç–∞–∫ –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä—É—á–Ω—É—é –æ–±—Ä–µ–∑–∫—É —á–µ—Ä–µ–∑ crop
    function createHeroAnimations(scene) {
      // –ù–µ —Å–æ–∑–¥–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏–∏, —Ç–∞–∫ –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä—É—á–Ω—É—é –æ–±—Ä–µ–∑–∫—É —á–µ—Ä–µ–∑ setCrop()
      console.log('‚úÖ Using manual crop approach - no animations needed');
      
      // #region agent log
      logDebug('home_uchi_hero.html:createHeroAnimations', 'Using manual crop', {
        approach: 'manual_crop',
        frameWidth: scene.heroFrameWidth,
        frameHeight: scene.heroFrameHeight,
        frameCount: scene.heroFrameCount
      }, 'B');
      // #endregion
    }
    
    function update() {
      // Update animations, etc.
    }
    
    // Create map background - –∫—Ä–∞—Å–∏–≤—ã–π —Ñ–æ–Ω —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º –∏ —Å–ø—Ä–∞–π—Ç–∞–º–∏ –¥–µ—Ä–µ–≤—å–µ–≤
    function createMapBackground(scene) {
      const worldWidth = 3000;
      const worldHeight = 3000;
      const centerX = worldWidth / 2;
      const centerY = worldHeight / 2;
      
      // –°–æ–∑–¥–∞–µ–º –∫—Ä–∞—Å–∏–≤—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω (–Ω–µ–±–æ ‚Üí —Ç—Ä–∞–≤–∞)
      const skyColor = 0x87CEEB; // –ù–µ–±–µ—Å–Ω–æ-–≥–æ–ª—É–±–æ–π
      const grassColor = 0x7CB342; // –°–≤–µ–∂–∞—è –∑–µ–ª–µ–Ω–∞—è —Ç—Ä–∞–≤–∞
      const earthColor = 0x8D6E63; // –ö–æ—Ä–∏—á–Ω–µ–≤–∞—è –∑–µ–º–ª—è
      
      // –ë–∞–∑–æ–≤—ã–π —Å–ª–æ–π –Ω–µ–±–∞
      const skyBg = scene.add.rectangle(centerX, centerY, worldWidth, worldHeight, skyColor);
      skyBg.setDepth(-100);
      
      // –ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –∫ —Ç—Ä–∞–≤–µ (—Å–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ª–æ–µ–≤)
      const gradientLayers = 20;
      for (let i = 0; i < gradientLayers; i++) {
        const yPos = (worldHeight / gradientLayers) * i;
        const ratio = i / gradientLayers;
        const color = Phaser.Display.Color.Interpolate.ColorWithColor(
          Phaser.Display.Color.ValueToColor(skyColor),
          Phaser.Display.Color.ValueToColor(grassColor),
          gradientLayers,
          i
        );
        const layerColor = Phaser.Display.Color.GetColor(color.r, color.g, color.b);
        
        const layer = scene.add.rectangle(
          centerX,
          yPos + (worldHeight / gradientLayers) / 2,
          worldWidth,
          worldHeight / gradientLayers,
          layerColor
        );
        layer.setDepth(-99);
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ç—Ä–∞–≤—É (—Ç–∞–π–ª—ã)
      const grassTileSize = 128;
      for (let y = 0; y < worldHeight; y += grassTileSize) {
        for (let x = 0; x < worldWidth; x += grassTileSize) {
          // –í–∞—Ä–∏–∞—Ü–∏—è —Ü–≤–µ—Ç–∞ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤–∏–¥–∞
          const variation = Math.random() * 0.15;
          const tileColor = Phaser.Display.Color.ValueToColor(grassColor);
          if (Math.random() > 0.5) {
            tileColor.brighten(10 * variation);
          } else {
            tileColor.darken(10 * variation);
          }
          
          const tile = scene.add.rectangle(
            x + grassTileSize / 2,
            y + grassTileSize / 2,
            grassTileSize,
            grassTileSize,
            tileColor.color
          );
          tile.setDepth(-98);
          tile.setAlpha(0.4 + variation * 0.3);
        }
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º —É—á–∞—Å—Ç–∫–∏ –∑–µ–º–ª–∏
      for (let i = 0; i < 20; i++) {
        const patchX = Phaser.Math.Between(150, worldWidth - 150);
        const patchY = Phaser.Math.Between(150, worldHeight - 150);
        const patchSize = Phaser.Math.Between(100, 200);
        
        const patch = scene.add.ellipse(patchX, patchY, patchSize, patchSize * 0.7, earthColor);
        patch.setDepth(-97);
        patch.setAlpha(0.3);
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–∞—Å–∏–≤—ã–µ –¥–µ—Ä–µ–≤—å—è (—É–ª—É—á—à–µ–Ω–Ω—ã–µ —Å–ø—Ä–∞–π—Ç—ã)
      for (let i = 0; i < 80; i++) {
        const treeX = Phaser.Math.Between(100, worldWidth - 100);
        const treeY = Phaser.Math.Between(100, worldHeight - 100);
        const treeScale = Phaser.Math.FloatBetween(0.8, 1.3);
        const treeType = Phaser.Math.Between(0, 2); // 3 —Ç–∏–ø–∞ –¥–µ—Ä–µ–≤—å–µ–≤
        
        // –°—Ç–≤–æ–ª –¥–µ—Ä–µ–≤–∞
        const trunkHeight = 20 * treeScale;
        const trunkWidth = 6 * treeScale;
        const trunk = scene.add.rectangle(
          treeX,
          treeY + trunkHeight / 2,
          trunkWidth,
          trunkHeight,
          0x5D4037
        );
        trunk.setDepth(-96);
        
        // –ö—Ä–æ–Ω–∞ –¥–µ—Ä–µ–≤–∞ (—Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã)
        let crownColor, crownSize;
        if (treeType === 0) {
          // –•–≤–æ–π–Ω–æ–µ –¥–µ—Ä–µ–≤–æ (—Ç–µ–º–Ω–æ-–∑–µ–ª–µ–Ω–æ–µ)
          crownColor = 0x2E7D32;
          crownSize = 25 * treeScale;
          const crown = scene.add.circle(treeX, treeY - 5, crownSize, crownColor);
          crown.setDepth(-96);
        } else if (treeType === 1) {
          // –õ–∏—Å—Ç–≤–µ–Ω–Ω–æ–µ –¥–µ—Ä–µ–≤–æ (—Å–≤–µ—Ç–ª–æ-–∑–µ–ª–µ–Ω–æ–µ)
          crownColor = 0x66BB6A;
          crownSize = 30 * treeScale;
          const crown = scene.add.circle(treeX, treeY - 8, crownSize, crownColor);
          crown.setDepth(-96);
          // –î–æ–±–∞–≤–ª—è–µ–º –≤—Ç–æ—Ä–æ–π —Å–ª–æ–π –¥–ª—è –æ–±—ä–µ–º–∞
          const crown2 = scene.add.circle(treeX + 5, treeY - 10, crownSize * 0.7, 0x81C784);
          crown2.setDepth(-96);
          crown2.setAlpha(0.7);
        } else {
          // –ü–∞–ª—å–º–∞ (–≤—ã—Å–æ–∫–∞—è)
          crownColor = 0x558B2F;
          crownSize = 20 * treeScale;
          const crown = scene.add.circle(treeX, treeY - 15, crownSize, crownColor);
          crown.setDepth(-96);
          // –õ–∏—Å—Ç—å—è –ø–∞–ª—å–º—ã
          for (let leaf = 0; leaf < 4; leaf++) {
            const angle = (leaf * Math.PI * 2) / 4;
            const leafX = treeX + Math.cos(angle) * 15;
            const leafY = treeY - 20 + Math.sin(angle) * 10;
            const leafSprite = scene.add.ellipse(leafX, leafY, 12, 25, crownColor);
            leafSprite.setDepth(-96);
            leafSprite.setRotation(angle);
          }
        }
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º –≤–æ–¥–æ–µ–º—ã
      for (let i = 0; i < 8; i++) {
        const waterX = Phaser.Math.Between(200, worldWidth - 200);
        const waterY = Phaser.Math.Between(200, worldHeight - 200);
        const waterSize = Phaser.Math.Between(120, 250);
        const waterColor = 0x42A5F5; // –ì–æ–ª—É–±–∞—è –≤–æ–¥–∞
        
        const water = scene.add.ellipse(waterX, waterY, waterSize, waterSize * 0.85, waterColor);
        water.setDepth(-95);
        water.setAlpha(0.65);
        
        // –≠—Ñ—Ñ–µ–∫—Ç –≤–æ–ª–Ω
        const waveGraphics = scene.add.graphics();
        waveGraphics.lineStyle(2, 0xFFFFFF, 0.4);
        for (let w = 0; w < waterSize; w += 20) {
          const waveY = waterY + Math.sin(w / 15) * 8;
          waveGraphics.beginPath();
          waveGraphics.moveTo(waterX - waterSize / 2 + w, waveY);
          waveGraphics.lineTo(waterX - waterSize / 2 + w + 15, waveY);
          waveGraphics.strokePath();
        }
        waveGraphics.setDepth(-94);
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∫–∞–º–Ω–∏
      for (let i = 0; i < 25; i++) {
        const rockX = Phaser.Math.Between(80, worldWidth - 80);
        const rockY = Phaser.Math.Between(80, worldHeight - 80);
        const rockSize = Phaser.Math.Between(8, 18);
        const rockColor = 0x757575;
        
        const rock = scene.add.circle(rockX, rockY, rockSize, rockColor);
        rock.setDepth(-93);
        rock.setAlpha(0.6);
      }
      
      console.log('‚úÖ Enhanced map background created with trees and gradient');
    }
    
    // Load lessons from API
    async function loadLessons(scene) {
      try {
        console.log('üì° Loading lessons from API...');
        const response = await fetch('/api/lessons/');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.error) {
          console.error('API error:', data.error_message);
          showErrorMessage(scene, data.error_message);
          return;
        }
        
        lessons = data.lessons || [];
        console.log(`‚úÖ Loaded ${lessons.length} lessons`);
        
        // Process lessons
        lessons.forEach(lesson => {
          if (lesson.user_completed) {
            completedLessons.add(lesson.id);
          }
          lessonStars[lesson.id] = lesson.stars || 0;
        });
        
        updateStats();
        
        // Create lesson sprites
        createLessonSprites(scene);
        
        // Position camera to show all lessons
        fitCameraToLessons(scene);
        
      } catch (error) {
        console.error('Error loading lessons:', error);
        showErrorMessage(scene, '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —É—Ä–æ–∫–æ–≤. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É.');
      }
    }
    
    // Create lesson sprites (islands)
    function createLessonSprites(scene) {
      // Clear existing sprites
      scene.lessonSprites.forEach(sprite => sprite.destroy());
      scene.lessonSprites = [];
      scene.paths.forEach(path => path.destroy());
      scene.paths = [];
      
      lessons.forEach((lesson, index) => {
        const pos = lessonPositions[index % lessonPositions.length];
        const isUnlocked = isLessonUnlocked(index);
        const isCompleted = completedLessons.has(lesson.id);
        const stars = lessonStars[lesson.id] || 0;
        
        // Draw path to previous lesson
        if (index > 0) {
          const prevPos = lessonPositions[(index - 1) % lessonPositions.length];
          const path = scene.add.graphics();
          
          const lineWidth = isUnlocked ? 6 : 3;
          const lineColor = isUnlocked ? 0x8B4513 : 0xCCCCCC;
          
          if (isUnlocked) {
            // Solid line for unlocked path
            path.lineStyle(lineWidth, lineColor);
            path.beginPath();
            path.moveTo(prevPos.x, prevPos.y);
            const midX = (prevPos.x + pos.x) / 2;
            const midY = (prevPos.y + pos.y) / 2 - 20;
            path.quadraticCurveTo(midX, midY, pos.x, pos.y);
            path.strokePath();
          } else {
            // Dashed line for locked path - draw manually
            const dx = pos.x - prevPos.x;
            const dy = pos.y - prevPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const dashLength = 10;
            const gapLength = 5;
            const segments = Math.floor(distance / (dashLength + gapLength));
            
            path.lineStyle(lineWidth, lineColor);
            for (let i = 0; i < segments; i++) {
              const t1 = (i * (dashLength + gapLength)) / distance;
              const t2 = ((i * (dashLength + gapLength)) + dashLength) / distance;
              
              // Calculate points on quadratic curve
              const getPointOnCurve = (t) => {
                const x1 = prevPos.x;
                const y1 = prevPos.y;
                const x2 = (prevPos.x + pos.x) / 2;
                const y2 = (prevPos.y + pos.y) / 2 - 20;
                const x3 = pos.x;
                const y3 = pos.y;
                
                const mt = 1 - t;
                return {
                  x: mt * mt * x1 + 2 * mt * t * x2 + t * t * x3,
                  y: mt * mt * y1 + 2 * mt * t * y2 + t * t * y3
                };
              };
              
              const p1 = getPointOnCurve(t1);
              const p2 = getPointOnCurve(t2);
              
              path.moveTo(p1.x, p1.y);
              path.lineTo(p2.x, p2.y);
            }
            path.strokePath();
          }
          
          path.setDepth(0);
          scene.paths.push(path);
        }
        
        // Create island (circle) - larger for Heroes 3 style
        const islandColor = isCompleted ? 0x66BB6A : (isUnlocked ? 0xFFC107 : 0x757575);
        const islandRadius = 50; // Larger island
        const island = scene.add.circle(pos.x, pos.y, islandRadius, islandColor);
        island.setStrokeStyle(4, 0xFFFFFF);
        island.setDepth(1);
        island.setInteractive({ useHandCursor: true });
        
        // Add shadow under island
        const shadow = scene.add.ellipse(pos.x + 3, pos.y + 3, islandRadius * 2, islandRadius * 1.2, 0x000000);
        shadow.setAlpha(0.3);
        shadow.setDepth(0);
        
        // Add lesson number text
        const numberText = scene.add.text(pos.x, pos.y, (index + 1).toString(), {
          fontSize: '20px',
          fontWeight: 'bold',
          color: '#333',
          align: 'center'
        });
        numberText.setOrigin(0.5);
        numberText.setDepth(2);
        
        // Add stars text below island (further down for larger island)
        const starText = stars > 0 ? '‚≠ê'.repeat(stars) : '‚òÜ‚òÜ‚òÜ';
        const starsDisplay = scene.add.text(pos.x, pos.y + 80, starText, {
          fontSize: '18px',
          color: stars > 0 ? '#FFD700' : '#CCCCCC',
          align: 'center',
          fontStyle: 'bold'
        });
        starsDisplay.setOrigin(0.5);
        starsDisplay.setDepth(2);
        
        // Add lock icon if locked
        if (!isUnlocked) {
          const lockIcon = scene.add.text(pos.x, pos.y - 70, 'üîí', {
            fontSize: '24px',
            align: 'center'
          });
          lockIcon.setOrigin(0.5);
          lockIcon.setDepth(2);
        }
        
        // Click handler
        island.on('pointerdown', () => {
          if (isUnlocked) {
            window.location.href = `/uchi/lesson/${lesson.id}/topics/`;
          } else {
            console.log('Lesson locked! Need 2+ stars on previous lesson.');
          }
        });
        
        // Store sprite reference
        scene.lessonSprites.push({
          island,
          numberText,
          starsDisplay,
          lessonId: lesson.id,
          index
        });
      });
      
      // Create hero sprite on current lesson
      createHeroSprite(scene);
    }
    
    // Create hero sprite - Heroes 3 style (large, standing on location)
    // Using spritesheet from GIF
    function createHeroSprite(scene) {
      // Remove existing hero
      if (scene.heroSprite) {
        if (scene.heroIdleTween) scene.heroIdleTween.destroy();
        if (scene.heroWarmupTimer) clearTimeout(scene.heroWarmupTimer);
        scene.heroSprite.destroy();
      }
      
        const currentIndex = getCurrentLessonIndex();
        if (currentIndex >= 0) {
        const pos = lessonPositions[currentIndex % lessonPositions.length];
        
        // Create hero sprite from frame texture
        const frameWidth = scene.heroFrameWidth || 73;
        const frameHeight = scene.heroFrameHeight || 98;
        const totalFrames = scene.heroTotalFrames || 50;
        
        // Scale hero to fit on island (diameter 100px)
        // Target height: ~90-110px –¥–ª—è –Ω–æ–≤–æ–≥–æ –≥–µ—Ä–æ—è
        const scale = 100 / frameHeight;
        
        console.log(`üé® Creating hero sprite from frame texture:`);
        console.log(`   Frame size: ${frameWidth}x${frameHeight}`);
        console.log(`   Total frames: ${totalFrames}`);
        console.log(`   Scale: ${scale.toFixed(2)}`);
        
        // #region agent log
        logDebug('home_uchi_hero.html:createHeroSprite', 'Creating sprite with frame texture', {
          frameWidth,
          frameHeight,
          totalFrames,
          scale,
          position: { x: pos.x, y: pos.y - 60 }
        }, 'C');
        // #endregion
        
        // –°–æ–∑–¥–∞–µ–º —Å–ø—Ä–∞–π—Ç –∏–∑ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–¥–µ–ª—å–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É)
        const firstFrameKey = 'hero-frame-0';
        scene.heroSprite = scene.add.image(pos.x, pos.y - 60, firstFrameKey);
        scene.heroSprite.setScale(scale);
        scene.heroSprite.setDepth(15); // Above everything
        scene.heroSprite.setOrigin(0.5, 1); // Anchor at bottom center (feet on island)
        
        console.log(`   Using texture: ${firstFrameKey}`);
        console.log(`   Sprite display size: ${(frameWidth * scale).toFixed(1)}x${(frameHeight * scale).toFixed(1)}`);
        
        // #region agent log
        logDebug('home_uchi_hero.html:createHeroSprite', 'Sprite created with frame texture', {
          textureKey: firstFrameKey,
          frameWidth,
          frameHeight,
          spriteScale: scale,
          spriteDepth: 15
        }, 'C');
        // #endregion
        
        // Store position for animations
        scene.heroBasePos = { x: pos.x, y: pos.y - 60 };
        scene.heroState = 'idle';
        scene.heroCurrentPose = 0;
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–µ 3-4 –∫–∞–¥—Ä–∞ –¥–ª—è idle –ø–æ–∑ (–ø–µ—Ä–≤—ã–π —Ä—è–¥)
        scene.heroIdlePoseCount = Math.min(3, scene.heroGridCols - 1); // –ü–µ—Ä–≤—ã–π —Ä—è–¥, –ø–µ—Ä–≤—ã–µ 4 –∫–∞–¥—Ä–∞
        scene.heroTotalFrames = totalFrames;
        scene.heroFrameWidth = frameWidth;
        scene.heroFrameHeight = frameHeight;
        scene.heroGridRows = scene.heroGridRows || 4;
        scene.heroGridCols = scene.heroGridCols || 10;
        
        // Start switching idle poses every 2 seconds
        startIdlePoseSwitching(scene);
        
        // Start periodic warmup (attack animation)
        startHeroWarmupCycle(scene);
        
        console.log(`‚úÖ Hero sprite created from hero-frame-0 at lesson ${currentIndex + 1}`);
        console.log(`   Total frames: ${totalFrames}, Idle poses: ${scene.heroIdlePoseCount + 1}`);
      }
    }
    
    // Switch between idle poses every 2 seconds - –º–µ–Ω—è–µ–º cropX –≤—Ä—É—á–Ω—É—é
    function startIdlePoseSwitching(scene) {
      if (!scene.heroSprite || scene.heroState !== 'idle') return;
      
      // Clear existing timer
      if (scene.idlePoseTimer) {
        clearTimeout(scene.idlePoseTimer);
      }
      
      // Switch to next pose (–∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–¥—Ä—ã –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —Ä—è–¥–∞ –¥–ª—è idle)
      // –ù–æ–≤—ã–π –≥–µ—Ä–æ–π: 5 —Ä—è–¥–æ–≤ √ó 10 –∫–æ–ª–æ–Ω–æ–∫, –ø–µ—Ä–≤—ã–µ 4 –∫–∞–¥—Ä–∞ –ø–µ—Ä–≤–æ–≥–æ —Ä—è–¥–∞ (0-3) –¥–ª—è idle
      const gridCols = scene.heroGridCols || 10;
      const availablePoses = 3; // –ü–µ—Ä–≤—ã–µ 4 –∫–∞–¥—Ä–∞ –ø–µ—Ä–≤–æ–≥–æ —Ä—è–¥–∞ (0, 1, 2, 3)
      scene.heroCurrentPose = (scene.heroCurrentPose + 1) % (availablePoses + 1);
      
      // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ —Ç–µ–∫—Å—Ç—É—Ä—É –Ω—É–∂–Ω–æ–≥–æ –∫–∞–¥—Ä–∞
      const frameKey = `hero-frame-${scene.heroCurrentPose}`;
      
      console.log(`üîÑ Switching to pose ${scene.heroCurrentPose}:`);
      console.log(`   Texture: ${frameKey}`);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞
      if (scene.textures.exists(frameKey)) {
        // –ú–µ–Ω—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É —Å–ø—Ä–∞–π—Ç–∞
        scene.heroSprite.setTexture(frameKey);
        console.log(`   ‚úÖ Texture switched to ${frameKey}`);
      } else {
        console.error(`‚ùå Texture ${frameKey} doesn't exist!`);
      }
      
      // #region agent log
      logDebug('home_uchi_hero.html:startIdlePoseSwitching', 'Pose switched with texture', {
        newPose: scene.heroCurrentPose,
        availablePoses: availablePoses + 1,
        textureKey: frameKey,
        textureExists: scene.textures.exists(frameKey)
      }, 'D');
      // #endregion
      
      // Schedule next switch in 2 seconds
      scene.idlePoseTimer = setTimeout(() => {
        startIdlePoseSwitching(scene);
      }, 2000);
    }
    
    // Idle animation - just switch poses, no continuous animation
    function startHeroIdleAnimation(scene) {
      if (!scene.heroSprite) return;
      scene.heroState = 'idle';
      // Poses are switched by startIdlePoseSwitching()
    }
    
    // Periodic warmup - draw sword and practice swings
    function startHeroWarmupCycle(scene) {
      if (!scene.heroSprite) return;
      
      // Random interval between 8-15 seconds
      const interval = Phaser.Math.Between(8000, 15000);
      
      scene.heroWarmupTimer = setTimeout(() => {
        performHeroWarmup(scene);
      }, interval);
    }
    
    // Perform warmup sequence: show attack frame
    function performHeroWarmup(scene) {
      if (!scene.heroSprite || scene.heroState !== 'idle') {
        startHeroWarmupCycle(scene); // Try again later
        return;
      }
      
      scene.heroState = 'attacking';
      
      // Stop pose switching
      if (scene.idlePoseTimer) {
        clearTimeout(scene.idlePoseTimer);
        scene.idlePoseTimer = null;
      }
      
      // Show attack frame - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–¥—Ä—ã –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä—è–¥–∞ (5-–π —Ä—è–¥)
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–¥—Ä—ã –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä—è–¥–∞ (5-–π —Ä—è–¥, –∏–Ω–¥–µ–∫—Å—ã —Å –∞—Ç–∞–∫–∞–º–∏)
      // –ü–æ—Å–ª–µ–¥–Ω–∏–π —Ä—è–¥ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –∏–Ω–¥–µ–∫—Å–∞: (gridRows - 1) * gridCols
      const gridRows = scene.heroGridRows || 5;
      const gridCols = scene.heroGridCols || 10;
      const lastRowStart = (gridRows - 1) * gridCols; // 4 * 10 = 40
      // –ë–µ—Ä–µ–º –æ–¥–∏–Ω –∏–∑ –∫–∞–¥—Ä–æ–≤ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä—è–¥–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä—è–¥–∞)
      const attackFrame = lastRowStart; // –ö–∞–¥—Ä 40 (–ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä 5-–≥–æ —Ä—è–¥–∞)
      const attackFrameKey = `hero-frame-${attackFrame}`;
      
      // –ú–µ–Ω—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –Ω–∞ –∫–∞–¥—Ä —Å –º–µ—á–æ–º
      if (scene.textures.exists(attackFrameKey)) {
        scene.heroSprite.setTexture(attackFrameKey);
        console.log(`‚öîÔ∏è Showing attack frame ${attackFrame} (row ${gridRows - 1}, col 0)`);
        console.log(`   Texture: ${attackFrameKey}`);
        console.log(`   Grid: ${gridRows} rows √ó ${gridCols} cols`);
      } else {
        console.error(`‚ùå Attack texture ${attackFrameKey} doesn't exist!`);
      }
      
      // #region agent log
      logDebug('home_uchi_hero.html:performHeroWarmup', 'Showing attack frame with texture', {
        attackFrame,
        lastRowStart,
        gridRows: gridRows,
        gridCols: gridCols,
        totalFrames: scene.heroTotalFrames,
        textureKey: attackFrameKey,
        textureExists: scene.textures.exists(attackFrameKey)
      }, 'D');
      // #endregion
      
      // After 1 second, return to idle
      setTimeout(() => {
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Ç–µ–∫—É—â–µ–π idle –ø–æ–∑–µ —á–µ—Ä–µ–∑ —Ç–µ–∫—Å—Ç—É—Ä—É
        const currentPoseKey = `hero-frame-${scene.heroCurrentPose}`;
        if (scene.textures.exists(currentPoseKey)) {
          scene.heroSprite.setTexture(currentPoseKey);
        }
        scene.heroState = 'idle';
        startIdlePoseSwitching(scene); // Resume pose switching
        startHeroWarmupCycle(scene); // Schedule next warmup
      }, 1000);
    }
    
    // Fit camera to show all lessons
    function fitCameraToLessons(scene) {
      if (lessons.length === 0) return;
      
      const usedPositions = lessons.map((_, index) => lessonPositions[index % lessonPositions.length]);
      
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      usedPositions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        maxX = Math.max(maxX, pos.x);
        minY = Math.min(minY, pos.y);
        maxY = Math.max(maxY, pos.y);
      });
      
      const padding = 150;
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      const worldWidth = (maxX - minX) + padding * 2;
      const worldHeight = (maxY - minY) + padding * 2;
      
      const zoomX = scene.cameras.main.width / worldWidth;
      const zoomY = scene.cameras.main.height / worldHeight;
      const fitZoom = Math.min(zoomX, zoomY) * 0.9;
      
      scene.cameras.main.setZoom(Math.max(0.5, Math.min(2.0, fitZoom)));
      scene.cameras.main.centerOn(centerX, centerY);
      
      console.log('üìπ Camera fitted to lessons:', {centerX, centerY, zoom: fitZoom});
    }
    
    // Setup camera controls
    function setupCameraControls(scene) {
      let isDragging = false;
      let dragStart = { x: 0, y: 0 };
      let cameraStart = { x: 0, y: 0 };
      
      // Mouse drag
      scene.input.on('pointerdown', (pointer) => {
        if (pointer.leftButtonDown()) {
          isDragging = true;
          dragStart.x = pointer.x;
          dragStart.y = pointer.y;
          cameraStart.x = scene.cameras.main.scrollX;
          cameraStart.y = scene.cameras.main.scrollY;
        }
      });
      
      scene.input.on('pointermove', (pointer) => {
        if (isDragging && pointer.isDown) {
          const dx = (pointer.x - dragStart.x) / scene.cameras.main.zoom;
          const dy = (pointer.y - dragStart.y) / scene.cameras.main.zoom;
          scene.cameras.main.setScroll(
            cameraStart.x - dx,
            cameraStart.y - dy
          );
        }
      });
      
      scene.input.on('pointerup', () => {
        isDragging = false;
      });
      
      // Zoom with mouse wheel (Ctrl + wheel)
      const mapWrapper = document.getElementById('mapWrapper');
      mapWrapper.addEventListener('wheel', (e) => {
        if (e.ctrlKey) {
          e.preventDefault();
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          const newZoom = Phaser.Math.Clamp(
            scene.cameras.main.zoom * delta,
            0.5,
            2.0
          );
          scene.cameras.main.setZoom(newZoom);
        }
      });
      
      // Zoom buttons
      document.getElementById('zoomIn').addEventListener('click', () => {
        const newZoom = Math.min(2.0, scene.cameras.main.zoom * 1.2);
        scene.cameras.main.setZoom(newZoom);
      });
      
      document.getElementById('zoomOut').addEventListener('click', () => {
        const newZoom = Math.max(0.5, scene.cameras.main.zoom * 0.8);
        scene.cameras.main.setZoom(newZoom);
      });
      
      document.getElementById('resetView').addEventListener('click', () => {
        fitCameraToLessons(scene);
      });
    }
    
    // Helper functions
    function isLessonUnlocked(index) {
      if (index === 0) return true;
      const prevLesson = lessons[index - 1];
      const prevStars = lessonStars[prevLesson.id] || 0;
      return prevStars >= 2;
    }
    
    function getCurrentLessonIndex() {
      for (let i = 0; i < lessons.length; i++) {
        if (!completedLessons.has(lessons[i].id)) {
          return i;
        }
      }
      return lessons.length - 1;
    }
    
    function updateStats() {
      document.getElementById('completedLessons').textContent = completedLessons.size;
      const totalStars = Object.values(lessonStars).reduce((a, b) => a + b, 0);
      document.getElementById('totalStars').textContent = totalStars;
      document.getElementById('userScore').textContent = Math.round(avatarData.score || 0);
    }
    
    function showErrorMessage(scene, message) {
      const text = scene.add.text(
        scene.cameras.main.centerX,
        scene.cameras.main.centerY,
        message,
        {
          fontSize: '28px',
          color: '#c62828',
          align: 'center',
          wordWrap: { width: 600 }
        }
      );
      text.setOrigin(0.5);
      text.setDepth(100);
    }
    
    // Initialize game when Phaser is loaded
    window.addEventListener('load', () => {
      if (typeof Phaser !== 'undefined') {
        gameInstance = new Phaser.Game(config);
        console.log('üéÆ Phaser game initialized');
      } else {
        console.error('‚ùå Phaser library not loaded!');
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      if (gameInstance && gameInstance.scene.scenes[0]) {
        const mapWrapper = document.getElementById('mapWrapper');
        gameInstance.scale.resize(mapWrapper.clientWidth, mapWrapper.clientHeight);
      }
    });
  </script>
</body>
</html>
